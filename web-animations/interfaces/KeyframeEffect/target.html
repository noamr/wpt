<!DOCTYPE html>
<meta charset=utf-8>
<title>KeyframeEffect.target</title>
<link rel="help"
  href="https://drafts.csswg.org/web-animations/#dom-keyframeeffect-target">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../../testcommon.js"></script>
<style>
  .pseudo::before {content: 'foo'; display: inline-block;}
  .pseudoa::before {margin-left: 10px;}
  .pseudob::before {margin-left: 20px;}
</style>
<body>
<div id="log"></div>
<script>
'use strict';

const gKeyFrames = { 'marginLeft': ['0px', '100px'] };

test(t => {
  const div = createDiv(t);
  const effect = new KeyframeEffect(null, gKeyFrames, 100 * MS_PER_SEC);
  effect.target = div;

  const anim = new Animation(effect, document.timeline);
  anim.play();

  anim.currentTime = 50 * MS_PER_SEC;
  assert_equals(getComputedStyle(div).marginLeft, '50px',
                'Value at 50% progress');
}, 'Test setting target before constructing the associated animation');

test(t => {
  const div = createDiv(t);
  div.style.marginLeft = '10px';
  const effect = new KeyframeEffect(null, gKeyFrames, 100 * MS_PER_SEC);
  const anim = new Animation(effect, document.timeline);
  anim.play();

  anim.currentTime = 50 * MS_PER_SEC;
  assert_equals(getComputedStyle(div).marginLeft, '10px',
                'Value at 50% progress before setting new target');
  effect.target = div;
  assert_equals(getComputedStyle(div).marginLeft, '50px',
                'Value at 50% progress after setting new target');
}, 'Test setting target from null to a valid target');

test(t => {
  const div = createDiv(t);
  div.style.marginLeft = '10px';
  const anim = div.animate(gKeyFrames, 100 * MS_PER_SEC);

  anim.currentTime = 50 * MS_PER_SEC;
  assert_equals(getComputedStyle(div).marginLeft, '50px',
                'Value at 50% progress before clearing the target')

  anim.effect.target = null;
  assert_equals(getComputedStyle(div).marginLeft, '10px',
                'Value after clearing the target')
}, 'Test setting target from a valid target to null');

test(t => {
  const a = createDiv(t);
  const b = createDiv(t);
  a.style.marginLeft = '10px';
  b.style.marginLeft = '20px';
  const anim = a.animate(gKeyFrames, 100 * MS_PER_SEC);

  anim.currentTime = 50 * MS_PER_SEC;
  assert_equals(getComputedStyle(a).marginLeft, '50px',
                'Value of 1st element (currently targeted) before ' +
                'changing the effect target');
  assert_equals(getComputedStyle(b).marginLeft, '20px',
                'Value of 2nd element (currently not targeted) before ' +
                'changing the effect target');
  anim.effect.target = b;
  assert_equals(getComputedStyle(a).marginLeft, '10px',
                'Value of 1st element (currently not targeted) after ' +
                'changing the effect target');
  assert_equals(getComputedStyle(b).marginLeft, '50px',
                'Value of 2nd element (currently targeted) after ' +
                'changing the effect target');

  // This makes sure the animation property is changed correctly on new
  // targeted element.
  anim.currentTime = 75 * MS_PER_SEC;
  assert_equals(getComputedStyle(b).marginLeft, '75px',
                'Value of 2nd target (currently targeted) after ' +
                'changing the animation current time.');
}, 'Test setting target from a valid target to another target');

promise_test(async t => {
  const animation = createDiv(t).animate(
    { opacity: 0 },
    { duration: 1, fill: 'forwards' }
  );

  const foreignElement
    = document.createElementNS('http://example.org/test', 'test');
  document.body.appendChild(foreignElement);
  t.add_cleanup(() => {
    foreignElement.remove();
  });

  animation.effect.target = foreignElement;

  // Wait a frame to make sure nothing bad happens when the UA tries to update
  // style.
  await waitForNextFrame();
}, 'Target element can be set to a foreign element');


function pseudoTargetTest(a, b) {
  a.classList.add('pseudoa');
  b.classList.add('pseudob');
  // sync on updating the pseudo-elements
  getComputedStyle(a,"::before").content;
  getComputedStyle(b,"::before").content;
  const anim = a.animate(gKeyFrames, {duration: 100 * MS_PER_SEC, pseudoElement: '::before'});

  anim.currentTime = 50 * MS_PER_SEC;
  anim.effect.target = b;
  assert_equals(anim.effect.target, b,
                "Animation targets specified element (target element)");
  assert_equals(anim.effect.pseudoElement, '::before',
                "Animation targets specified element (pseudo-selector)");
  assert_equals(getComputedStyle(a, '::before').marginLeft, '10px',
                'Value of 1st element (currently not targeted) after ' +
                'changing the effect target');
  assert_equals(getComputedStyle(b, '::before').marginLeft, '50px',
                'Value of 2nd element (currently targeted) after ' +
                'changing the effect target');
}

test(t => {
  const a = createDiv(t);
  const b = createDiv(t);
  a.classList.add('pseudo');
  b.classList.add('pseudo');
  pseudoTargetTest(a,b)
}, 'Test setting target from an existing pseudo-element to another existing pseudo-element');

test(t => {
  const a = createDiv(t);
  const b = createDiv(t);
  b.classList.add('pseudo');
  pseudoTargetTest(a,b)
}, 'Test setting target from a non-existing pseudo-element to an existing pseudo-element');

test(t => {
  const a = createDiv(t);
  const b = createDiv(t);
  a.classList.add('pseudo');
  pseudoTargetTest(a,b)
}, 'Test setting target from an existing pseudo-element to a non-existing pseudo-element');

test(t => {
  const a = createDiv(t);
  const b = createDiv(t);
  pseudoTargetTest(a,b)
}, 'Test setting target from a non-existing pseudo-element to another non-existing pseudo-element');




</script>
</body>
